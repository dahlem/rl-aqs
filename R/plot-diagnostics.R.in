## Copyright (C) 2009 Dominik Dahlem <Dominik.Dahlem@cs.tcd.ie>
##
## This file is free software; as a special exception the author gives
## unlimited permission to copy and/or distribute it, with or without
## modifications, as long as this notice is preserved.
##
## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
## implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

## Author: Dominik Dahlem <Dominik.Dahlem@cs.tcd.ie>
## Maintainer: Dominik Dahlem <Dominik.Dahlem@cs.tcd.ie>
## Keywords: diagnostics
## Created: 15.04.2009


library(igraph)
library(ggplot2)


des.eventInSystemTime.sum <- function(g, simNum, replications) {
    dflocal <- data.frame(eventInSystemTimes=rep(0, replications));

    for (r in seq(1, replications)) {
      print(paste("Read graph: ", simNum, "/", r, "/graphs/graph", g, ".gml", sep=""))
      graphFile = paste(simNum, "/", r, "/graphs/graph", g, ".gml", sep="")
      graph = read.graph(graphFile, format="graphml")
      eventInSystemTimes <- get.vertex.attribute(graph, "avg_event_in_system_time");
      dflocal$eventInSystemTimes[r] <- sum(eventInSystemTimes)
    }

    ## calc mean and standard error
    return(list(g=g, mean=mean(dflocal$eventInSystemTimes), se=(sd(dflocal$eventInSystemTimes) / replications)))
}


des.diagnostic.eventInSystemTime.plot <- function(cl, simNum, replications, graphs, stopTime, ps=TRUE) {
  if (ps) {
    pdf(paste(simNum, "/graph-response-diagnostic-evo-plot.pdf", sep=""), onefile=FALSE, version=1.4)
  }

  interval <- stopTime / (graphs - 1);
  graphs <- graphs - 1
  df <- data.frame(time=rep(0, graphs), meanEventInSystemTime=rep(0, graphs), ucl=rep(0, graphs), lcl=rep(0, graphs));

  if (is.null(cl)) {
    result <- sapply(seq(1, graphs),
                     des.eventInSystemTime.sum,
                     simNum=simNum,
                     replications=replications)
  } else {
    # execute in a cluster clusterApplyLB
    result <- parSapply(cl, seq(1, graphs),
                        des.eventInSystemTime.sum,
                        simNum=simNum,
                        replications=replications)
  }

  result <- t(result)
  sortedResult <- result[order(unlist(result[,1])), ]
  df$time = seq(1, graphs) * interval;
  df$meanQVal = unlist(sortedResult[,2])
  df$ucl = df$meanQVal + 1.96 * unlist(sortedResult[,3])
  df$lcl = df$meanQVal - 1.96 * unlist(sortedResult[,3])

  p <- ggplot(df, aes(x=time, y=meanEventInSystemTime))
  p <- p + layer(geom = "line")
  p <- p + geom_smooth(aes(min=lcl, max=ucl), stat="identity")
  p <- p + scale_y_continuous("Mean Total Response Time")
  p <- p + scale_x_continuous("Time")
  p <- p + opts(title="Evolution of Mean Total Response Time")
  p <- p + theme_bw()
  print(p)

  if (ps) {
    dev.off()
  }
}

cl <- NULL

# if it was configured using MPI, load the snow library
if (@HAVE_MPI@) {
  library(snow)
}

message("Start with the diagnostics!")


if (@HAVE_MPI@) {
  # read the NODEFILE to find out how many nodes are participating in the cluster
  nodes <- read.table("NODEFILE")
  
  # make the cluster
  cl <- makeCluster(length(nodes$V1), type="MPI")

  clusterEvalQ(cl, library(igraph))
  clusterEvalQ(cl, library(ggplot2))
}

simulations <- read.csv("simulations.dat", header=TRUE)
print(simulations)

## (1) for all simulations
for (sim in simulations$sim_num) {
  graphs <- simulations[simulations$sim_num == sim,]$graphs
  reps <- simulations[simulations$sim_num == sim,]$actual_reps
  stopTime <- simulations[simulations$sim_num == sim,]$stop_time

  ## (2) print the 
  des.diagnostic.eventInSystemTime.plot(cl, sim, reps, graphs, stopTime, ps=TRUE)
}


# In case of unexpected program exceptions, clean up the cluster
.Last <- function()
{
  if (@HAVE_MPI@) {
    stopCluster(cl)
  }
}

message("Finished diagnostics.")
